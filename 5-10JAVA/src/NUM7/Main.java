package NUM7;

//Паттерн «Адаптер» позволяет какой-то объект с одним интерфейсом
//подстроить под другой интерфейс

//Паттерн «Мост» разделяет класс на две независимые части –
//абстракцию и реализацию

//Паттерн «Компоновщик» позволяет сгруппировать множество
//объектов в древовидную структуру

//Паттерн «Декоратор» позволяет добавлять новую функциональность
//объекту, является некоторой оберткой над классом. Не управляет
//жизненным циклом объекта.

//Паттерн «Фасад» используется для предоставления простой
//абстракции над некоей сложной системой

//Паттерн «Легковес» используется для экономии памяти, разделяя
//общее состояние между множеством объектов. Удобно
//использовать, когда есть очень много объектов с схожим состоянием.

//Паттерн «Заместитель» (Прокси) подставляет вместо объектов
//специальные объекты заместители, добавляя дополнительную логику вокруг
//вызовов методов. Может управлять жизненным циклом объекта,
//который проксирует.
import NUM7.Adapter.USB;
import NUM7.Adapter.USBTethering;
import NUM7.Bridge.*;

import java.nio.charset.Charset;

public class Main {
    //Структурные паттерны проектирования играют не менее важную
    //роль, нежели остальные паттерны. Они отвечают за построение удобной
    //структуры и иерархии классов, которая делает код более поддерживаемым.
    //Рассмотрим структурные паттерны проектирования: Адаптер и Мост.
    public static void main(String[] args) {
        adapter();
        bridge();
    }
    //Шаблон проектирования «Адаптер» используется для связи двух несовместимых интерфейсов.
    // Он позволяет объектам с несовместимыми интерфейсами работать вместе.
    public static void adapter(){
        byte[] byteArray = { 112, 114, 105, 118, 101, 116 }; //privet
        String str = new String(byteArray, Charset.forName("UTF-8"));//112, 114, 105, 118, 101, 116
        USB usb1 = new USB(123);
        usb1.write(byteArray);
        USBTethering usb2 = new USBTethering(usb1);
        usb2.sendMessage(str);
        System.out.println(usb2.receiveMessage());
    }

    // Интерфейс DrawingAPI реализуется двумя классами - OpenGLDrawingAPI и OpenGLES2DrawingAPI,
    // которые отвечают за рисование фигур.
    //
    // Абстрактный класс Shape содержит ссылку на объект DrawingAPI. Эта ссылка используется в методе draw(),
    // который вызывает соответствующий метод рисования фигуры в DrawingAPI.
    //
    // Конкретные классы фигур - Circle и Square - реализуют абстрактный класс Shape,
    // переопределяя метод draw() и вызывая методы рисования фигур: drawCircle в случае круга и drawSquare в случае квадрата.
    //
    //В функции bridge() создаются различные объекты Circle и Square, каждый из которых использует различный объект DrawingAPI.
    // Таким образом, благодаря паттерну мост, отделено представление фигур от реализации их рисования,
    // что позволяет изменять одно без влияния на другое.

    public static void bridge(){
        DrawingAPI drawingAPI = new OpenGLDrawingAPI();
        Shape shape1 = new Circle(1, 2, 3, drawingAPI);
        Shape shape2 = new Square(4, 5, 6, drawingAPI);
        shape1.draw();
        shape2.draw();

        drawingAPI = new OpenGLES2DrawingAPI();
        shape1 = new Circle(7, 8, 9, drawingAPI);
        shape2 = new Square(10, 11, 12, drawingAPI);
        shape1.draw();
        shape2.draw();
    }
}
